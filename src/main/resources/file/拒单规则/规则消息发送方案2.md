æ„Ÿè°¢æ‚¨çš„åé¦ˆï¼æˆ‘æ¥ä¸ºæ‚¨æä¾›æ›´è¯¦ç»†çš„Spring Boot 3.0é€‚é…ç‰ˆæœ¬ï¼Œå¹¶è¡¥å……æ‰€æœ‰ç¼ºå¤±çš„åŸºç¡€ç±»å®ç°ã€‚

## ğŸš€ Spring Boot 3.0 é€‚é…è¦ç‚¹

### 1. ä¾èµ–é…ç½®æ›´æ–° (pom.xml)

```
<properties>
    <java.version>17</java.version>
    <spring-boot.version>3.0.0</spring-boot.version>
</properties>

<dependencies>
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot RabbitMQ -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    
    <!-- Spring Boot Data Redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- Spring Boot Scheduling -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-scheduling</artifactId>
    </dependency>
    
    <!-- Drools ç›¸å…³ä¾èµ– -->
    <dependency>
        <groupId>org.drools</groupId>
        <artifactId>drools-core</artifactId>
        <version>8.40.0.Final</version>
    </dependency>
    <dependency>
        <groupId>org.drools</groupId>
        <artifactId>drools-compiler</artifactId>
        <version>8.40.0.Final</version>
    </dependency>
    
    <!-- Jakarta EE (Spring Boot 3.0 ä½¿ç”¨Jakartaæ›¿ä»£javax) -->
    <dependency>
        <groupId>jakarta.persistence</groupId>
        <artifactId>jakarta.persistence-api</artifactId>
        <version>3.1.0</version>
    </dependency>
</dependencies>
```

## ğŸ“‹ å®Œæ•´çš„åŸºç¡€ç±»å®ç°

### 1. å®ä½“ç±»å®šä¹‰

#### MessageLog å®ä½“ç±»

```
import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "mail_send_log")
public class MessageLog {
    @Id
    @Column(name = "msg_id", length = 64)
    private String msgId;
    
    @Column(name = "rule_version", length = 50)
    private String ruleVersion;
    
    @Column(name = "status")
    private Integer status = 0; // 0:æŠ•é€’ä¸­;1:æŠ•é€’æˆåŠŸ;2:æŠ•é€’å¤±è´¥
    
    @Column(name = "count")
    private Integer count = 0; // é‡è¯•æ¬¡æ•°
    
    @Column(name = "try_time")
    private LocalDateTime tryTime;
    
    @Column(name = "create_time", updatable = false)
    private LocalDateTime createTime = LocalDateTime.now();
    
    @Column(name = "update_time")
    private LocalDateTime updateTime = LocalDateTime.now();
    
    // Getterå’ŒSetteræ–¹æ³•
    public String getMsgId() { return msgId; }
    public void setMsgId(String msgId) { this.msgId = msgId; }
    
    public String getRuleVersion() { return ruleVersion; }
    public void setRuleVersion(String ruleVersion) { this.ruleVersion = ruleVersion; }
    
    public Integer getStatus() { return status; }
    public void setStatus(Integer status) { this.status = status; }
    
    public Integer getCount() { return count; }
    public void setCount(Integer count) { this.count = count; }
    
    public LocalDateTime getTryTime() { return tryTime; }
    public void setTryTime(LocalDateTime tryTime) { this.tryTime = tryTime; }
    
    public LocalDateTime getCreateTime() { return createTime; }
    public void setCreateTime(LocalDateTime createTime) { this.createTime = createTime; }
    
    public LocalDateTime getUpdateTime() { return updateTime; }
    public void setUpdateTime(LocalDateTime updateTime) { this.updateTime = updateTime; }
}
```

#### RuleUpdateEvent äº‹ä»¶ç±»

```
import java.io.Serializable;

public class RuleUpdateEvent implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String ruleVersion;
    private String ruleContent;
    private String ruleType; // DRL, Excelç­‰
    private String tenantId; // å¤šç§Ÿæˆ·æ”¯æŒ
    
    // Getterå’ŒSetteræ–¹æ³•
    public String getRuleVersion() { return ruleVersion; }
    public void setRuleVersion(String ruleVersion) { this.ruleVersion = ruleVersion; }
    
    public String getRuleContent() { return ruleContent; }
    public void setRuleContent(String ruleContent) { this.ruleContent = ruleContent; }
    
    public String getRuleType() { return ruleType; }
    public void setRuleType(String ruleType) { this.ruleType = ruleType; }
    
    public String getTenantId() { return tenantId; }
    public void setTenantId(String tenantId) { this.tenantId = tenantId; }
}
```

### 2. Repository å±‚å®ç°

#### MessageLogRepository

```
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface MessageLogRepository extends JpaRepository<MessageLog, String> {
    
    @Modifying
    @Query("UPDATE MessageLog SET status = :status, updateTime = CURRENT_TIMESTAMP WHERE msgId = :msgId")
    int updateStatus(@Param("msgId") String msgId, @Param("status") Integer status);
    
    @Modifying
    @Query("UPDATE MessageLog SET count = count + 1, tryTime = :tryTime, updateTime = CURRENT_TIMESTAMP WHERE msgId = :msgId")
    int updateCount(@Param("msgId") String msgId, @Param("tryTime") LocalDateTime tryTime);
    
    @Query("SELECT m FROM MessageLog m WHERE m.status = 0 AND m.count < 3 AND m.tryTime <= CURRENT_TIMESTAMP")
    List<MessageLog> findNeedRetryMessages();
    
    @Query("SELECT m FROM MessageLog m WHERE m.msgId = :msgId")
    MessageLog findByMsgId(@Param("msgId") String msgId);
}
```

### 3. Service å±‚å®Œæ•´å®ç°

#### MessageLogService å®ç°

```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Service
@Transactional
public class MessageLogService {
    
    @Autowired
    private MessageLogRepository messageLogRepository;
    
    public void insert(MessageLog messageLog) {
        messageLogRepository.save(messageLog);
    }
    
    public void updateStatus(String msgId, Integer status) {
        messageLogRepository.updateStatus(msgId, status);
    }
    
    public void updateCount(String msgId, LocalDateTime tryTime) {
        messageLogRepository.updateCount(msgId, tryTime);
    }
    
    public MessageLog getMessageById(String msgId) {
        return messageLogRepository.findByMsgId(msgId);
    }
    
    public List<MessageLog> getNeedRetryMessages() {
        return messageLogRepository.findNeedRetryMessages();
    }
}
```

#### RuleEngineService å¢å¼ºç‰ˆ

```
import org.kie.api.KieServices;
import org.kie.api.builder.*;
import org.kie.api.io.ResourceType;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RuleEngineService {
    private static final Logger logger = LoggerFactory.getLogger(RuleEngineService.class);
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    // ä½¿ç”¨ConcurrentHashMapå­˜å‚¨ä¸åŒç‰ˆæœ¬çš„KieSessionï¼ˆæ”¯æŒå¤šç§Ÿæˆ·ï¼‰
    private final Map<String, KieSession> kieSessionMap = new ConcurrentHashMap<>();
    private final Map<String, KieContainer> kieContainerMap = new ConcurrentHashMap<>();
    
    /**
     * åŠ¨æ€åŠ è½½è§„åˆ™
     */
    public synchronized boolean loadRule(String ruleContent, String ruleVersion, String tenantId) {
        String sessionKey = buildSessionKey(tenantId, ruleVersion);
        
        try {
            KieServices kieServices = KieServices.Factory.get();
            KieFileSystem kfs = kieServices.newKieFileSystem();
            
            // æ ¹æ®è§„åˆ™ç±»å‹é€‰æ‹©ä¸åŒçš„èµ„æºç±»å‹
            ResourceType resourceType = ResourceType.DRL;
            String fileName = "src/main/resources/rules/rule_" + ruleVersion + ".drl";
            
            kfs.write(fileName, ruleContent);
            
            KieBuilder kieBuilder = kieServices.newKieBuilder(kfs).buildAll();
            Results results = kieBuilder.getResults();
            
            if (results.hasMessages(Message.Level.ERROR)) {
                logger.error("è§„åˆ™ç¼–è¯‘é”™è¯¯: {}", results.getMessages());
                return false;
            }
            
            // é‡Šæ”¾æ—§çš„KieSession
            disposeOldSession(sessionKey);
            
            // åˆ›å»ºæ–°çš„KieContainerå’ŒKieSession
            KieRepository kieRepository = kieServices.getRepository();
            kieRepository.addKieModule(kieRepository::getDefaultReleaseId);
            
            KieContainer kieContainer = kieServices.newKieContainer(kieRepository.getDefaultReleaseId());
            KieSession kieSession = kieContainer.newKieSession();
            
            // ç¼“å­˜æ–°çš„KieSessionå’ŒKieContainer
            kieSessionMap.put(sessionKey, kieSession);
            kieContainerMap.put(sessionKey, kieContainer);
            
            // å°†è§„åˆ™å†…å®¹ç¼“å­˜åˆ°Redis
            cacheRuleToRedis(ruleContent, ruleVersion, tenantId);
            
            logger.info("è§„åˆ™å¼•æ“æ›´æ–°æˆåŠŸï¼Œç‰ˆæœ¬: {}, ç§Ÿæˆ·: {}", ruleVersion, tenantId);
            return true;
            
        } catch (Exception e) {
            logger.error("è§„åˆ™å¼•æ“æ›´æ–°å¤±è´¥ï¼Œç‰ˆæœ¬: {}, ç§Ÿæˆ·: {}", ruleVersion, tenantId, e);
            return false;
        }
    }
    
    /**
     * æ‰§è¡Œè§„åˆ™
     */
    public void executeRules(Object fact, String ruleVersion, String tenantId) {
        String sessionKey = buildSessionKey(tenantId, ruleVersion);
        KieSession kieSession = kieSessionMap.get(sessionKey);
        
        if (kieSession != null) {
            try {
                kieSession.insert(fact);
                int firedRules = kieSession.fireAllRules();
                logger.debug("è§„åˆ™æ‰§è¡Œå®Œæˆï¼Œè§¦å‘è§„åˆ™æ•°é‡: {}", firedRules);
            } catch (Exception e) {
                logger.error("è§„åˆ™æ‰§è¡Œå¤±è´¥", e);
                throw new RuntimeException("è§„åˆ™æ‰§è¡Œå¤±è´¥", e);
            } finally {
                if (kieSession != null) {
                    kieSession.dispose();
                }
            }
        } else {
            logger.warn("æœªæ‰¾åˆ°å¯¹åº”çš„è§„åˆ™ä¼šè¯ï¼Œç‰ˆæœ¬: {}, ç§Ÿæˆ·: {}", ruleVersion, tenantId);
        }
    }
    
    /**
     * è·å–è§„åˆ™å†…å®¹
     */
    public String getRuleContent(String ruleVersion, String tenantId) {
        String redisKey = "drools_rules:" + tenantId;
        return (String) redisTemplate.opsForHash().get(redisKey, ruleVersion);
    }
    
    private String buildSessionKey(String tenantId, String ruleVersion) {
        return tenantId + ":" + ruleVersion;
    }
    
    private void disposeOldSession(String sessionKey) {
        KieSession oldSession = kieSessionMap.remove(sessionKey);
        KieContainer oldContainer = kieContainerMap.remove(sessionKey);
        
        if (oldSession != null) {
            try {
                oldSession.dispose();
            } catch (Exception e) {
                logger.warn("é‡Šæ”¾æ—§çš„KieSessionå¤±è´¥", e);
            }
        }
        
        if (oldContainer != null) {
            try {
                oldContainer.dispose();
            } catch (Exception e) {
                logger.warn("é‡Šæ”¾æ—§çš„KieContainerå¤±è´¥", e);
            }
        }
    }
    
    private void cacheRuleToRedis(String ruleContent, String ruleVersion, String tenantId) {
        String redisKey = "drools_rules:" + tenantId;
        redisTemplate.opsForHash().put(redisKey, ruleVersion, ruleContent);
        // è®¾ç½®è¿‡æœŸæ—¶é—´24å°æ—¶
        redisTemplate.expire(redisKey, 24, java.util.concurrent.TimeUnit.HOURS);
    }
}
```

### 4. Spring Boot 3.0 é…ç½®æ›´æ–°

#### application.yml (Spring Boot 3.0 é€‚é…)

```
server:
  port: 8080

spring:
  application:
    name: drools-mq-integration
    
  # RabbitMQé…ç½®
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: ${RABBITMQ_VHOST:/}
    
    # ç”Ÿäº§è€…ç¡®è®¤æœºåˆ¶
    publisher-confirm-type: correlated
    publisher-returns: true
    
    # æ¶ˆè´¹è€…é…ç½®
    listener:
      simple:
        acknowledge-mode: manual
        prefetch: 1
        retry:
          enabled: true
          max-attempts: 3
          initial-interval: 2s
          multiplier: 2.0
          max-interval: 10s
    
  # Redisé…ç½®
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
    timeout: 2000ms
    
  # æ•°æ®æºé…ç½®
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:3306/drools_mq?useSSL=false&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:123456}
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  # JPAé…ç½®
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true

# æ—¥å¿—é…ç½®
logging:
  level:
    com.yourcompany.drools: DEBUG
    org.springframework.amqp: INFO
    org.drools: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"

# è‡ªå®šä¹‰é…ç½®
app:
  mq:
    max-retry-count: 3
    retry-interval: 60000 # 1åˆ†é’Ÿ
    message-ttl: 10000    # 10ç§’
```

#### RabbitMQé…ç½®ç±»æ›´æ–°

```
import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class RabbitConfig {
    
    @Value("${app.mq.max-retry-count:3}")
    private int maxRetryCount;
    
    @Value("${app.mq.message-ttl:10000}")
    private int messageTtl;
    
    // ä½¿ç”¨Jackson2JsonMessageConverteræ›¿ä»£é»˜è®¤çš„SimpleMessageConverter
    @Bean
    public Jackson2JsonMessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }
    
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(jsonMessageConverter());
        
        // æ¶ˆæ¯å‘é€åˆ°Brokerçš„å›è°ƒ
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
            String msgId = correlationData != null ? correlationData.getId() : "unknown";
            if (ack) {
                logger.info("æ¶ˆæ¯ {} å‘é€æˆåŠŸ", msgId);
            } else {
                logger.error("æ¶ˆæ¯ {} å‘é€å¤±è´¥ï¼ŒåŸå› : {}", msgId, cause);
            }
        });
        
        // æ¶ˆæ¯ä»Exchangeè·¯ç”±åˆ°Queueå¤±è´¥çš„å›è°ƒ
        rabbitTemplate.setReturnsCallback(returned -> {
            logger.error("æ¶ˆæ¯è·¯ç”±å¤±è´¥ï¼Œåº”ç­”ç :{}ï¼ŒåŸå› :{}ï¼Œäº¤æ¢æœº:{}ï¼Œè·¯ç”±é”®:{}ï¼Œæ¶ˆæ¯:{}", 
                    returned.getReplyCode(), returned.getReplyText(), 
                    returned.getExchange(), returned.getRoutingKey(), 
                    returned.getMessage());
        });
        
        return rabbitTemplate;
    }
    
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setMessageConverter(jsonMessageConverter());
        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
        factory.setPrefetchCount(1);
        return factory;
    }
    
    // é˜Ÿåˆ—å’Œäº¤æ¢æœºå£°æ˜ä¿æŒä¸å˜...
}
```

### 5. æ¶ˆè´¹è€…ç«¯å¢å¼ºå®ç°

#### RuleUpdateConsumer å®Œæ•´ç‰ˆ

```
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeUnit;

@Component
public class RuleUpdateConsumer {
    private static final Logger logger = LoggerFactory.getLogger(RuleUpdateConsumer.class);
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private RuleEngineService ruleEngineService;
    
    @Autowired
    private MessageLogService messageLogService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Value("${app.mq.max-retry-count:3}")
    private int maxRetryCount;
    
    private static final String MESSAGE_CACHE_KEY = "rule_update_processed";
    
    @RabbitListener(queues = "rule.update.queue")
    public void handleRuleUpdate(Message message, org.springframework.amqp.rabbit.listener.api.Channel channel) {
        Long deliveryTag = (Long) message.getMessageProperties().getHeaders().get("amqp_deliveryTag");
        String msgId = message.getMessageProperties().getCorrelationId();
        
        if (msgId == null) {
            logger.error("æ¶ˆæ¯IDä¸ºç©ºï¼Œæ‹’ç»æ¶ˆæ¯");
            basicNack(channel, deliveryTag, false);
            return;
        }
        
        try {
            // 1. å¹‚ç­‰æ€§æ£€æŸ¥
            if (isMessageProcessed(msgId)) {
                logger.info("æ¶ˆæ¯ {} å·²å¤„ç†ï¼Œç›´æ¥ç¡®è®¤", msgId);
                basicAck(channel, deliveryTag);
                return;
            }
            
            // 2. è§£ææ¶ˆæ¯å†…å®¹
            RuleUpdateEvent ruleUpdateEvent = parseMessage(message);
            if (ruleUpdateEvent == null) {
                throw new IllegalArgumentException("æ¶ˆæ¯è§£æå¤±è´¥");
            }
            
            String ruleVersion = ruleUpdateEvent.getRuleVersion();
            String tenantId = ruleUpdateEvent.getTenantId() != null ? ruleUpdateEvent.getTenantId() : "default";
            
            logger.info("å¼€å§‹å¤„ç†è§„åˆ™æ›´æ–°æ¶ˆæ¯: {}, è§„åˆ™ç‰ˆæœ¬: {}, ç§Ÿæˆ·: {}", msgId, ruleVersion, tenantId);
            
            // 3. å¤„ç†ä¸šåŠ¡é€»è¾‘
            boolean success = processRuleUpdate(ruleUpdateEvent, ruleVersion, tenantId);
            
            if (success) {
                // 4. å¤„ç†æˆåŠŸï¼Œè®°å½•å¹‚ç­‰æ€§
                markMessageAsProcessed(msgId);
                basicAck(channel, deliveryTag);
                logger.info("è§„åˆ™æ›´æ–°æ¶ˆæ¯å¤„ç†æˆåŠŸ: {}", msgId);
            } else {
                throw new RuntimeException("è§„åˆ™å¤„ç†å¤±è´¥");
            }
            
        } catch (Exception e) {
            logger.error("å¤„ç†è§„åˆ™æ›´æ–°æ¶ˆæ¯å¤±è´¥: {}", msgId, e);
            handleProcessingFailure(msgId, deliveryTag, channel, e);
        }
    }
    
    private boolean isMessageProcessed(String msgId) {
        Boolean exists = redisTemplate.opsForHash().hasKey(MESSAGE_CACHE_KEY, msgId);
        return Boolean.TRUE.equals(exists);
    }
    
    private RuleUpdateEvent parseMessage(Message message) {
        try {
            String messageBody = new String(message.getBody(), StandardCharsets.UTF_8);
            return objectMapper.readValue(messageBody, RuleUpdateEvent.class);
        } catch (Exception e) {
            logger.error("æ¶ˆæ¯è§£æå¤±è´¥", e);
            return null;
        }
    }
    
    private boolean processRuleUpdate(RuleUpdateEvent event, String ruleVersion, String tenantId) {
        try {
            // ä¼˜å…ˆä½¿ç”¨æ¶ˆæ¯ä¸­çš„è§„åˆ™å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»Redisè·å–
            String ruleContent = event.getRuleContent();
            if (ruleContent == null) {
                ruleContent = ruleEngineService.getRuleContent(ruleVersion, tenantId);
            }
            
            if (ruleContent == null) {
                logger.error("æœªæ‰¾åˆ°è§„åˆ™å†…å®¹ï¼Œç‰ˆæœ¬: {}, ç§Ÿæˆ·: {}", ruleVersion, tenantId);
                return false;
            }
            
            // åŠ¨æ€åŠ è½½è§„åˆ™åˆ°Droolså¼•æ“
            return ruleEngineService.loadRule(ruleContent, ruleVersion, tenantId);
            
        } catch (Exception e) {
            logger.error("è§„åˆ™å¤„ç†å¼‚å¸¸", e);
            return false;
        }
    }
    
    private void markMessageAsProcessed(String msgId) {
        try {
            redisTemplate.opsForHash().put(MESSAGE_CACHE_KEY, msgId, "processed");
            redisTemplate.expire(MESSAGE_CACHE_KEY, 24, TimeUnit.HOURS);
        } catch (Exception e) {
            logger.warn("è®°å½•å¹‚ç­‰æ€§å¤±è´¥: {}", msgId, e);
        }
    }
    
    private void handleProcessingFailure(String msgId, Long deliveryTag, 
                                       org.springframework.amqp.rabbit.listener.api.Channel channel, Exception e) {
        try {
            MessageLog messageLog = messageLogService.getMessageById(msgId);
            int currentRetryCount = messageLog != null ? messageLog.getCount() : 0;
            
            if (currentRetryCount >= maxRetryCount - 1) {
                logger.warn("æ¶ˆæ¯ {} å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè½¬å…¥æ­»ä¿¡é˜Ÿåˆ—", msgId);
                recordFailedMessage(msgId, e.getMessage());
                basicNack(channel, deliveryTag, false); // ä¸é‡æ–°å…¥é˜Ÿ
            } else {
                logger.info("æ¶ˆæ¯ {} é‡æ–°æ”¾å›é˜Ÿåˆ—ç­‰å¾…é‡è¯•ï¼Œå½“å‰é‡è¯•æ¬¡æ•°: {}", msgId, currentRetryCount);
                basicNack(channel, deliveryTag, true); // é‡æ–°å…¥é˜Ÿ
            }
        } catch (Exception ex) {
            logger.error("å¤„ç†å¤±è´¥é€»è¾‘å¼‚å¸¸", ex);
            basicNack(channel, deliveryTag, false);
        }
    }
    
    private void recordFailedMessage(String msgId, String errorMsg) {
        try {
            String failedKey = MESSAGE_CACHE_KEY + ":failed";
            redisTemplate.opsForHash().put(failedKey, msgId, errorMsg);
            redisTemplate.expire(failedKey, 72, TimeUnit.HOURS); // å¤±è´¥æ¶ˆæ¯ä¿ç•™3å¤©
        } catch (Exception e) {
            logger.warn("è®°å½•å¤±è´¥æ¶ˆæ¯å¤±è´¥: {}", msgId, e);
        }
    }
    
    private void basicAck(org.springframework.amqp.rabbit.listener.api.Channel channel, Long deliveryTag) {
        try {
            if (channel != null && channel.isOpen()) {
                channel.basicAck(deliveryTag, false);
            }
        } catch (IOException e) {
            logger.error("æ¶ˆæ¯ç¡®è®¤å¤±è´¥", e);
        }
    }
    
    private void basicNack(org.springframework.amqp.rabbit.listener.api.Channel channel, Long deliveryTag, boolean requeue) {
        try {
            if (channel != null && channel.isOpen()) {
                channel.basicNack(deliveryTag, false, requeue);
            }
        } catch (IOException e) {
            logger.error("æ¶ˆæ¯æ‹’ç»å¤±è´¥", e);
        }
    }
}
```

## ğŸ”§ æ•°æ®åº“è¡¨ç»“æ„æ›´æ–° (MySQL)

```
-- æ¶ˆæ¯æ—¥å¿—è¡¨
CREATE TABLE IF NOT EXISTS mail_send_log (
    msg_id VARCHAR(64) PRIMARY KEY COMMENT 'æ¶ˆæ¯å”¯ä¸€ID',
    rule_version VARCHAR(50) NOT NULL COMMENT 'è§„åˆ™ç‰ˆæœ¬å·',
    status TINYINT DEFAULT 0 COMMENT '0:æŠ•é€’ä¸­;1:æŠ•é€’æˆåŠŸ;2:æŠ•é€’å¤±è´¥',
    count TINYINT DEFAULT 0 COMMENT 'é‡è¯•æ¬¡æ•°',
    try_time DATETIME COMMENT 'ä¸‹æ¬¡é‡è¯•æ—¶é—´',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_status_count (status, count),
    INDEX idx_try_time (try_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='æ¶ˆæ¯å‘é€æ—¥å¿—è¡¨';

-- è§„åˆ™ç‰ˆæœ¬ç®¡ç†è¡¨
CREATE TABLE IF NOT EXISTS drools_rule_version (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    rule_version VARCHAR(50) NOT NULL UNIQUE COMMENT 'è§„åˆ™ç‰ˆæœ¬å·',
    rule_content LONGTEXT COMMENT 'è§„åˆ™å†…å®¹',
    rule_type VARCHAR(20) DEFAULT 'DRL' COMMENT 'è§„åˆ™ç±»å‹: DRL, Excelç­‰',
    tenant_id VARCHAR(50) DEFAULT 'default' COMMENT 'ç§Ÿæˆ·ID',
    status TINYINT DEFAULT 1 COMMENT 'çŠ¶æ€: 0-ç¦ç”¨, 1-å¯ç”¨',
    description VARCHAR(500) COMMENT 'è§„åˆ™æè¿°',
    creator VARCHAR(50) COMMENT 'åˆ›å»ºäºº',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_tenant_version (tenant_id, rule_version)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Droolsè§„åˆ™ç‰ˆæœ¬è¡¨';
```

